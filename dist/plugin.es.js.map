{"version":3,"file":"plugin.es.js","sources":["../node_modules/rollup-pluginutils/dist/pluginutils.es.js"],"sourcesContent":["import path, { extname, sep, resolve } from 'path';\nimport { walk } from 'estree-walker';\nimport util from 'util';\n\nconst addExtension = function addExtension(filename, ext = '.js') {\n    if (!extname(filename))\n        filename += ext;\n    return filename;\n};\n\nconst extractors = {\n    ArrayPattern(names, param) {\n        for (const element of param.elements) {\n            if (element)\n                extractors[element.type](names, element);\n        }\n    },\n    AssignmentPattern(names, param) {\n        extractors[param.left.type](names, param.left);\n    },\n    Identifier(names, param) {\n        names.push(param.name);\n    },\n    MemberExpression() { },\n    ObjectPattern(names, param) {\n        for (const prop of param.properties) {\n            if (prop.type === 'RestElement') {\n                extractors.RestElement(names, prop);\n            }\n            else {\n                extractors[prop.value.type](names, prop.value);\n            }\n        }\n    },\n    RestElement(names, param) {\n        extractors[param.argument.type](names, param.argument);\n    }\n};\nconst extractAssignedNames = function extractAssignedNames(param) {\n    const names = [];\n    extractors[param.type](names, param);\n    return names;\n};\n\nconst blockDeclarations = {\n    const: true,\n    let: true\n};\nclass Scope {\n    constructor(options = {}) {\n        this.parent = options.parent;\n        this.isBlockScope = !!options.block;\n        this.declarations = Object.create(null);\n        if (options.params) {\n            options.params.forEach(param => {\n                extractAssignedNames(param).forEach(name => {\n                    this.declarations[name] = true;\n                });\n            });\n        }\n    }\n    addDeclaration(node, isBlockDeclaration, isVar) {\n        if (!isBlockDeclaration && this.isBlockScope) {\n            // it's a `var` or function node, and this\n            // is a block scope, so we need to go up\n            this.parent.addDeclaration(node, isBlockDeclaration, isVar);\n        }\n        else if (node.id) {\n            extractAssignedNames(node.id).forEach(name => {\n                this.declarations[name] = true;\n            });\n        }\n    }\n    contains(name) {\n        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n    }\n}\nconst attachScopes = function attachScopes(ast, propertyName = 'scope') {\n    let scope = new Scope();\n    walk(ast, {\n        enter(node, parent) {\n            // function foo () {...}\n            // class Foo {...}\n            if (/(Function|Class)Declaration/.test(node.type)) {\n                scope.addDeclaration(node, false, false);\n            }\n            // var foo = 1\n            if (node.type === 'VariableDeclaration') {\n                const kind = node.kind;\n                const isBlockDeclaration = blockDeclarations[kind];\n                node.declarations.forEach((declaration) => {\n                    scope.addDeclaration(declaration, isBlockDeclaration, true);\n                });\n            }\n            let newScope;\n            // create new function scope\n            if (/Function/.test(node.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: false,\n                    params: node.params\n                });\n                // named function expressions - the name is considered\n                // part of the function's scope\n                if (node.type === 'FunctionExpression' && node.id) {\n                    newScope.addDeclaration(node, false, false);\n                }\n            }\n            // create new block scope\n            if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: true\n                });\n            }\n            // catch clause has its own block scope\n            if (node.type === 'CatchClause') {\n                newScope = new Scope({\n                    parent: scope,\n                    params: node.param ? [node.param] : [],\n                    block: true\n                });\n            }\n            if (newScope) {\n                Object.defineProperty(node, propertyName, {\n                    value: newScope,\n                    configurable: true\n                });\n                scope = newScope;\n            }\n        },\n        leave(node) {\n            if (node[propertyName])\n                scope = scope.parent;\n        }\n    });\n    return scope;\n};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar utils = createCommonjsModule(function (module, exports) {\n    exports.isInteger = num => {\n        if (typeof num === 'number') {\n            return Number.isInteger(num);\n        }\n        if (typeof num === 'string' && num.trim() !== '') {\n            return Number.isInteger(Number(num));\n        }\n        return false;\n    };\n    /**\n     * Find a node of the given type\n     */\n    exports.find = (node, type) => node.nodes.find(node => node.type === type);\n    /**\n     * Find a node of the given type\n     */\n    exports.exceedsLimit = (min, max, step = 1, limit) => {\n        if (limit === false)\n            return false;\n        if (!exports.isInteger(min) || !exports.isInteger(max))\n            return false;\n        return ((Number(max) - Number(min)) / Number(step)) >= limit;\n    };\n    /**\n     * Escape the given node with '\\\\' before node.value\n     */\n    exports.escapeNode = (block, n = 0, type) => {\n        let node = block.nodes[n];\n        if (!node)\n            return;\n        if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n            if (node.escaped !== true) {\n                node.value = '\\\\' + node.value;\n                node.escaped = true;\n            }\n        }\n    };\n    /**\n     * Returns true if the given brace node should be enclosed in literal braces\n     */\n    exports.encloseBrace = node => {\n        if (node.type !== 'brace')\n            return false;\n        if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n            node.invalid = true;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns true if a brace node is invalid.\n     */\n    exports.isInvalidBrace = block => {\n        if (block.type !== 'brace')\n            return false;\n        if (block.invalid === true || block.dollar)\n            return true;\n        if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n            block.invalid = true;\n            return true;\n        }\n        if (block.open !== true || block.close !== true) {\n            block.invalid = true;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns true if a node is an open or close node\n     */\n    exports.isOpenOrClose = node => {\n        if (node.type === 'open' || node.type === 'close') {\n            return true;\n        }\n        return node.open === true || node.close === true;\n    };\n    /**\n     * Reduce an array of text nodes.\n     */\n    exports.reduce = nodes => nodes.reduce((acc, node) => {\n        if (node.type === 'text')\n            acc.push(node.value);\n        if (node.type === 'range')\n            node.type = 'text';\n        return acc;\n    }, []);\n    /**\n     * Flatten an array\n     */\n    exports.flatten = (...args) => {\n        const result = [];\n        const flat = arr => {\n            for (let i = 0; i < arr.length; i++) {\n                let ele = arr[i];\n                Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n            }\n            return result;\n        };\n        flat(args);\n        return result;\n    };\n});\nvar utils_1 = utils.isInteger;\nvar utils_2 = utils.find;\nvar utils_3 = utils.exceedsLimit;\nvar utils_4 = utils.escapeNode;\nvar utils_5 = utils.encloseBrace;\nvar utils_6 = utils.isInvalidBrace;\nvar utils_7 = utils.isOpenOrClose;\nvar utils_8 = utils.reduce;\nvar utils_9 = utils.flatten;\n\nvar stringify = (ast, options = {}) => {\n    let stringify = (node, parent = {}) => {\n        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options.escapeInvalid === true;\n        let output = '';\n        if (node.value) {\n            if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n                return '\\\\' + node.value;\n            }\n            return node.value;\n        }\n        if (node.value) {\n            return node.value;\n        }\n        if (node.nodes) {\n            for (let child of node.nodes) {\n                output += stringify(child);\n            }\n        }\n        return output;\n    };\n    return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\nvar isNumber = function (num) {\n    if (typeof num === 'number') {\n        return num - num === 0;\n    }\n    if (typeof num === 'string' && num.trim() !== '') {\n        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n    }\n    return false;\n};\n\nconst toRegexRange = (min, max, options) => {\n    if (isNumber(min) === false) {\n        throw new TypeError('toRegexRange: expected the first argument to be a number');\n    }\n    if (max === void 0 || min === max) {\n        return String(min);\n    }\n    if (isNumber(max) === false) {\n        throw new TypeError('toRegexRange: expected the second argument to be a number.');\n    }\n    let opts = Object.assign({ relaxZeros: true }, options);\n    if (typeof opts.strictZeros === 'boolean') {\n        opts.relaxZeros = opts.strictZeros === false;\n    }\n    let relax = String(opts.relaxZeros);\n    let shorthand = String(opts.shorthand);\n    let capture = String(opts.capture);\n    let wrap = String(opts.wrap);\n    let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n        return toRegexRange.cache[cacheKey].result;\n    }\n    let a = Math.min(min, max);\n    let b = Math.max(min, max);\n    if (Math.abs(a - b) === 1) {\n        let result = min + '|' + max;\n        if (opts.capture) {\n            return `(${result})`;\n        }\n        if (opts.wrap === false) {\n            return result;\n        }\n        return `(?:${result})`;\n    }\n    let isPadded = hasPadding(min) || hasPadding(max);\n    let state = { min, max, a, b };\n    let positives = [];\n    let negatives = [];\n    if (isPadded) {\n        state.isPadded = isPadded;\n        state.maxLen = String(state.max).length;\n    }\n    if (a < 0) {\n        let newMin = b < 0 ? Math.abs(b) : 1;\n        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n        a = state.a = 0;\n    }\n    if (b >= 0) {\n        positives = splitToPatterns(a, b, state, opts);\n    }\n    state.negatives = negatives;\n    state.positives = positives;\n    state.result = collatePatterns(negatives, positives, opts);\n    if (opts.capture === true) {\n        state.result = `(${state.result})`;\n    }\n    else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n        state.result = `(?:${state.result})`;\n    }\n    toRegexRange.cache[cacheKey] = state;\n    return state.result;\n};\nfunction collatePatterns(neg, pos, options) {\n    let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n    let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n    let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n    return subpatterns.join('|');\n}\nfunction splitToRanges(min, max) {\n    let nines = 1;\n    let zeros = 1;\n    let stop = countNines(min, nines);\n    let stops = new Set([max]);\n    while (min <= stop && stop <= max) {\n        stops.add(stop);\n        nines += 1;\n        stop = countNines(min, nines);\n    }\n    stop = countZeros(max + 1, zeros) - 1;\n    while (min < stop && stop <= max) {\n        stops.add(stop);\n        zeros += 1;\n        stop = countZeros(max + 1, zeros) - 1;\n    }\n    stops = [...stops];\n    stops.sort(compare);\n    return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\nfunction rangeToPattern(start, stop, options) {\n    if (start === stop) {\n        return { pattern: start, count: [], digits: 0 };\n    }\n    let zipped = zip(start, stop);\n    let digits = zipped.length;\n    let pattern = '';\n    let count = 0;\n    for (let i = 0; i < digits; i++) {\n        let [startDigit, stopDigit] = zipped[i];\n        if (startDigit === stopDigit) {\n            pattern += startDigit;\n        }\n        else if (startDigit !== '0' || stopDigit !== '9') {\n            pattern += toCharacterClass(startDigit, stopDigit, options);\n        }\n        else {\n            count++;\n        }\n    }\n    if (count) {\n        pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n    }\n    return { pattern, count: [count], digits };\n}\nfunction splitToPatterns(min, max, tok, options) {\n    let ranges = splitToRanges(min, max);\n    let tokens = [];\n    let start = min;\n    let prev;\n    for (let i = 0; i < ranges.length; i++) {\n        let max = ranges[i];\n        let obj = rangeToPattern(String(start), String(max), options);\n        let zeros = '';\n        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n            if (prev.count.length > 1) {\n                prev.count.pop();\n            }\n            prev.count.push(obj.count[0]);\n            prev.string = prev.pattern + toQuantifier(prev.count);\n            start = max + 1;\n            continue;\n        }\n        if (tok.isPadded) {\n            zeros = padZeros(max, tok, options);\n        }\n        obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n        tokens.push(obj);\n        start = max + 1;\n        prev = obj;\n    }\n    return tokens;\n}\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n    let result = [];\n    for (let ele of arr) {\n        let { string } = ele;\n        // only push if _both_ are negative...\n        if (!intersection && !contains(comparison, 'string', string)) {\n            result.push(prefix + string);\n        }\n        // or _both_ are positive\n        if (intersection && contains(comparison, 'string', string)) {\n            result.push(prefix + string);\n        }\n    }\n    return result;\n}\n/**\n * Zip strings\n */\nfunction zip(a, b) {\n    let arr = [];\n    for (let i = 0; i < a.length; i++)\n        arr.push([a[i], b[i]]);\n    return arr;\n}\nfunction compare(a, b) {\n    return a > b ? 1 : b > a ? -1 : 0;\n}\nfunction contains(arr, key, val) {\n    return arr.some(ele => ele[key] === val);\n}\nfunction countNines(min, len) {\n    return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\nfunction countZeros(integer, zeros) {\n    return integer - (integer % Math.pow(10, zeros));\n}\nfunction toQuantifier(digits) {\n    let [start = 0, stop = ''] = digits;\n    if (stop || start > 1) {\n        return `{${start + (stop ? ',' + stop : '')}}`;\n    }\n    return '';\n}\nfunction toCharacterClass(a, b, options) {\n    return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\nfunction hasPadding(str) {\n    return /^-?(0+)\\d/.test(str);\n}\nfunction padZeros(value, tok, options) {\n    if (!tok.isPadded) {\n        return value;\n    }\n    let diff = Math.abs(tok.maxLen - String(value).length);\n    let relax = options.relaxZeros !== false;\n    switch (diff) {\n        case 0:\n            return '';\n        case 1:\n            return relax ? '0?' : '0';\n        case 2:\n            return relax ? '0{0,2}' : '00';\n        default: {\n            return relax ? `0{0,${diff}}` : `0{${diff}}`;\n        }\n    }\n}\n/**\n * Cache\n */\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n/**\n * Expose `toRegexRange`\n */\nvar toRegexRange_1 = toRegexRange;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nconst transform = toNumber => {\n    return value => toNumber === true ? Number(value) : String(value);\n};\nconst isValidValue = value => {\n    return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\nconst isNumber$1 = num => Number.isInteger(+num);\nconst zeros = input => {\n    let value = `${input}`;\n    let index = -1;\n    if (value[0] === '-')\n        value = value.slice(1);\n    if (value === '0')\n        return false;\n    while (value[++index] === '0')\n        ;\n    return index > 0;\n};\nconst stringify$1 = (start, end, options) => {\n    if (typeof start === 'string' || typeof end === 'string') {\n        return true;\n    }\n    return options.stringify === true;\n};\nconst pad = (input, maxLength, toNumber) => {\n    if (maxLength > 0) {\n        let dash = input[0] === '-' ? '-' : '';\n        if (dash)\n            input = input.slice(1);\n        input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n    }\n    if (toNumber === false) {\n        return String(input);\n    }\n    return input;\n};\nconst toMaxLen = (input, maxLength) => {\n    let negative = input[0] === '-' ? '-' : '';\n    if (negative) {\n        input = input.slice(1);\n        maxLength--;\n    }\n    while (input.length < maxLength)\n        input = '0' + input;\n    return negative ? ('-' + input) : input;\n};\nconst toSequence = (parts, options) => {\n    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n    let prefix = options.capture ? '' : '?:';\n    let positives = '';\n    let negatives = '';\n    let result;\n    if (parts.positives.length) {\n        positives = parts.positives.join('|');\n    }\n    if (parts.negatives.length) {\n        negatives = `-(${prefix}${parts.negatives.join('|')})`;\n    }\n    if (positives && negatives) {\n        result = `${positives}|${negatives}`;\n    }\n    else {\n        result = positives || negatives;\n    }\n    if (options.wrap) {\n        return `(${prefix}${result})`;\n    }\n    return result;\n};\nconst toRange = (a, b, isNumbers, options) => {\n    if (isNumbers) {\n        return toRegexRange_1(a, b, Object.assign({ wrap: false }, options));\n    }\n    let start = String.fromCharCode(a);\n    if (a === b)\n        return start;\n    let stop = String.fromCharCode(b);\n    return `[${start}-${stop}]`;\n};\nconst toRegex = (start, end, options) => {\n    if (Array.isArray(start)) {\n        let wrap = options.wrap === true;\n        let prefix = options.capture ? '' : '?:';\n        return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n    }\n    return toRegexRange_1(start, end, options);\n};\nconst rangeError = (...args) => {\n    return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\nconst invalidRange = (start, end, options) => {\n    if (options.strictRanges === true)\n        throw rangeError([start, end]);\n    return [];\n};\nconst invalidStep = (step, options) => {\n    if (options.strictRanges === true) {\n        throw new TypeError(`Expected step \"${step}\" to be a number`);\n    }\n    return [];\n};\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n    let a = Number(start);\n    let b = Number(end);\n    if (!Number.isInteger(a) || !Number.isInteger(b)) {\n        if (options.strictRanges === true)\n            throw rangeError([start, end]);\n        return [];\n    }\n    // fix negative zero\n    if (a === 0)\n        a = 0;\n    if (b === 0)\n        b = 0;\n    let descending = a > b;\n    let startString = String(start);\n    let endString = String(end);\n    let stepString = String(step);\n    step = Math.max(Math.abs(step), 1);\n    let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n    let toNumber = padded === false && stringify$1(start, end, options) === false;\n    let format = options.transform || transform(toNumber);\n    if (options.toRegex && step === 1) {\n        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n    }\n    let parts = { negatives: [], positives: [] };\n    let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n    let range = [];\n    let index = 0;\n    while (descending ? a >= b : a <= b) {\n        if (options.toRegex === true && step > 1) {\n            push(a);\n        }\n        else {\n            range.push(pad(format(a, index), maxLen, toNumber));\n        }\n        a = descending ? a - step : a + step;\n        index++;\n    }\n    if (options.toRegex === true) {\n        return step > 1\n            ? toSequence(parts, options)\n            : toRegex(range, null, Object.assign({ wrap: false }, options));\n    }\n    return range;\n};\nconst fillLetters = (start, end, step = 1, options = {}) => {\n    if ((!isNumber$1(start) && start.length > 1) || (!isNumber$1(end) && end.length > 1)) {\n        return invalidRange(start, end, options);\n    }\n    let format = options.transform || (val => String.fromCharCode(val));\n    let a = `${start}`.charCodeAt(0);\n    let b = `${end}`.charCodeAt(0);\n    let descending = a > b;\n    let min = Math.min(a, b);\n    let max = Math.max(a, b);\n    if (options.toRegex && step === 1) {\n        return toRange(min, max, false, options);\n    }\n    let range = [];\n    let index = 0;\n    while (descending ? a >= b : a <= b) {\n        range.push(format(a, index));\n        a = descending ? a - step : a + step;\n        index++;\n    }\n    if (options.toRegex === true) {\n        return toRegex(range, null, { wrap: false, options });\n    }\n    return range;\n};\nconst fill = (start, end, step, options = {}) => {\n    if (end == null && isValidValue(start)) {\n        return [start];\n    }\n    if (!isValidValue(start) || !isValidValue(end)) {\n        return invalidRange(start, end, options);\n    }\n    if (typeof step === 'function') {\n        return fill(start, end, 1, { transform: step });\n    }\n    if (isObject(step)) {\n        return fill(start, end, 0, step);\n    }\n    let opts = Object.assign({}, options);\n    if (opts.capture === true)\n        opts.wrap = true;\n    step = step || opts.step || 1;\n    if (!isNumber$1(step)) {\n        if (step != null && !isObject(step))\n            return invalidStep(step, opts);\n        return fill(start, end, 1, step);\n    }\n    if (isNumber$1(start) && isNumber$1(end)) {\n        return fillNumbers(start, end, step, opts);\n    }\n    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\nvar fillRange = fill;\n\nconst compile = (ast, options = {}) => {\n    let walk = (node, parent = {}) => {\n        let invalidBlock = utils.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options.escapeInvalid === true;\n        let invalid = invalidBlock === true || invalidNode === true;\n        let prefix = options.escapeInvalid === true ? '\\\\' : '';\n        let output = '';\n        if (node.isOpen === true) {\n            return prefix + node.value;\n        }\n        if (node.isClose === true) {\n            return prefix + node.value;\n        }\n        if (node.type === 'open') {\n            return invalid ? (prefix + node.value) : '(';\n        }\n        if (node.type === 'close') {\n            return invalid ? (prefix + node.value) : ')';\n        }\n        if (node.type === 'comma') {\n            return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n        }\n        if (node.value) {\n            return node.value;\n        }\n        if (node.nodes && node.ranges > 0) {\n            let args = utils.reduce(node.nodes);\n            let range = fillRange(...args, Object.assign({}, options, { wrap: false, toRegex: true }));\n            if (range.length !== 0) {\n                return args.length > 1 && range.length > 1 ? `(${range})` : range;\n            }\n        }\n        if (node.nodes) {\n            for (let child of node.nodes) {\n                output += walk(child, node);\n            }\n        }\n        return output;\n    };\n    return walk(ast);\n};\nvar compile_1 = compile;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n    let result = [];\n    queue = [].concat(queue);\n    stash = [].concat(stash);\n    if (!stash.length)\n        return queue;\n    if (!queue.length) {\n        return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n    }\n    for (let item of queue) {\n        if (Array.isArray(item)) {\n            for (let value of item) {\n                result.push(append(value, stash, enclose));\n            }\n        }\n        else {\n            for (let ele of stash) {\n                if (enclose === true && typeof ele === 'string')\n                    ele = `{${ele}}`;\n                result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n            }\n        }\n    }\n    return utils.flatten(result);\n};\nconst expand = (ast, options = {}) => {\n    let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n    let walk = (node, parent = {}) => {\n        node.queue = [];\n        let p = parent;\n        let q = parent.queue;\n        while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n            p = p.parent;\n            q = p.queue;\n        }\n        if (node.invalid || node.dollar) {\n            q.push(append(q.pop(), stringify(node, options)));\n            return;\n        }\n        if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n            q.push(append(q.pop(), ['{}']));\n            return;\n        }\n        if (node.nodes && node.ranges > 0) {\n            let args = utils.reduce(node.nodes);\n            if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n                throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n            }\n            let range = fillRange(...args, options);\n            if (range.length === 0) {\n                range = stringify(node, options);\n            }\n            q.push(append(q.pop(), range));\n            node.nodes = [];\n            return;\n        }\n        let enclose = utils.encloseBrace(node);\n        let queue = node.queue;\n        let block = node;\n        while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n            block = block.parent;\n            queue = block.queue;\n        }\n        for (let i = 0; i < node.nodes.length; i++) {\n            let child = node.nodes[i];\n            if (child.type === 'comma' && node.type === 'brace') {\n                if (i === 1)\n                    queue.push('');\n                queue.push('');\n                continue;\n            }\n            if (child.type === 'close') {\n                q.push(append(q.pop(), queue, enclose));\n                continue;\n            }\n            if (child.value && child.type !== 'open') {\n                queue.push(append(queue.pop(), child.value));\n                continue;\n            }\n            if (child.nodes) {\n                walk(child, node);\n            }\n        }\n        return queue;\n    };\n    return utils.flatten(walk(ast));\n};\nvar expand_1 = expand;\n\nvar constants = {\n    MAX_LENGTH: 1024 * 64,\n    // Digits\n    CHAR_0: '0',\n    CHAR_9: '9',\n    // Alphabet chars.\n    CHAR_UPPERCASE_A: 'A',\n    CHAR_LOWERCASE_A: 'a',\n    CHAR_UPPERCASE_Z: 'Z',\n    CHAR_LOWERCASE_Z: 'z',\n    CHAR_LEFT_PARENTHESES: '(',\n    CHAR_RIGHT_PARENTHESES: ')',\n    CHAR_ASTERISK: '*',\n    // Non-alphabetic chars.\n    CHAR_AMPERSAND: '&',\n    CHAR_AT: '@',\n    CHAR_BACKSLASH: '\\\\',\n    CHAR_BACKTICK: '`',\n    CHAR_CARRIAGE_RETURN: '\\r',\n    CHAR_CIRCUMFLEX_ACCENT: '^',\n    CHAR_COLON: ':',\n    CHAR_COMMA: ',',\n    CHAR_DOLLAR: '$',\n    CHAR_DOT: '.',\n    CHAR_DOUBLE_QUOTE: '\"',\n    CHAR_EQUAL: '=',\n    CHAR_EXCLAMATION_MARK: '!',\n    CHAR_FORM_FEED: '\\f',\n    CHAR_FORWARD_SLASH: '/',\n    CHAR_HASH: '#',\n    CHAR_HYPHEN_MINUS: '-',\n    CHAR_LEFT_ANGLE_BRACKET: '<',\n    CHAR_LEFT_CURLY_BRACE: '{',\n    CHAR_LEFT_SQUARE_BRACKET: '[',\n    CHAR_LINE_FEED: '\\n',\n    CHAR_NO_BREAK_SPACE: '\\u00A0',\n    CHAR_PERCENT: '%',\n    CHAR_PLUS: '+',\n    CHAR_QUESTION_MARK: '?',\n    CHAR_RIGHT_ANGLE_BRACKET: '>',\n    CHAR_RIGHT_CURLY_BRACE: '}',\n    CHAR_RIGHT_SQUARE_BRACKET: ']',\n    CHAR_SEMICOLON: ';',\n    CHAR_SINGLE_QUOTE: '\\'',\n    CHAR_SPACE: ' ',\n    CHAR_TAB: '\\t',\n    CHAR_UNDERSCORE: '_',\n    CHAR_VERTICAL_LINE: '|',\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\n/**\n * Constants\n */\nconst { MAX_LENGTH, CHAR_BACKSLASH, /* \\ */ CHAR_BACKTICK, /* ` */ CHAR_COMMA, /* , */ CHAR_DOT, /* . */ CHAR_LEFT_PARENTHESES, /* ( */ CHAR_RIGHT_PARENTHESES, /* ) */ CHAR_LEFT_CURLY_BRACE, /* { */ CHAR_RIGHT_CURLY_BRACE, /* } */ CHAR_LEFT_SQUARE_BRACKET, /* [ */ CHAR_RIGHT_SQUARE_BRACKET, /* ] */ CHAR_DOUBLE_QUOTE, /* \" */ CHAR_SINGLE_QUOTE, /* ' */ CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE } = constants;\n/**\n * parse\n */\nconst parse = (input, options = {}) => {\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    let opts = options || {};\n    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    if (input.length > max) {\n        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n    }\n    let ast = { type: 'root', input, nodes: [] };\n    let stack = [ast];\n    let block = ast;\n    let prev = ast;\n    let brackets = 0;\n    let length = input.length;\n    let index = 0;\n    let depth = 0;\n    let value;\n    /**\n     * Helpers\n     */\n    const advance = () => input[index++];\n    const push = node => {\n        if (node.type === 'text' && prev.type === 'dot') {\n            prev.type = 'text';\n        }\n        if (prev && prev.type === 'text' && node.type === 'text') {\n            prev.value += node.value;\n            return;\n        }\n        block.nodes.push(node);\n        node.parent = block;\n        node.prev = prev;\n        prev = node;\n        return node;\n    };\n    push({ type: 'bos' });\n    while (index < length) {\n        block = stack[stack.length - 1];\n        value = advance();\n        /**\n         * Invalid chars\n         */\n        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n            continue;\n        }\n        /**\n         * Escaped chars\n         */\n        if (value === CHAR_BACKSLASH) {\n            push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n            continue;\n        }\n        /**\n         * Right square bracket (literal): ']'\n         */\n        if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n            push({ type: 'text', value: '\\\\' + value });\n            continue;\n        }\n        /**\n         * Left square bracket: '['\n         */\n        if (value === CHAR_LEFT_SQUARE_BRACKET) {\n            brackets++;\n            let next;\n            while (index < length && (next = advance())) {\n                value += next;\n                if (next === CHAR_LEFT_SQUARE_BRACKET) {\n                    brackets++;\n                    continue;\n                }\n                if (next === CHAR_BACKSLASH) {\n                    value += advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n                    brackets--;\n                    if (brackets === 0) {\n                        break;\n                    }\n                }\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Parentheses\n         */\n        if (value === CHAR_LEFT_PARENTHESES) {\n            block = push({ type: 'paren', nodes: [] });\n            stack.push(block);\n            push({ type: 'text', value });\n            continue;\n        }\n        if (value === CHAR_RIGHT_PARENTHESES) {\n            if (block.type !== 'paren') {\n                push({ type: 'text', value });\n                continue;\n            }\n            block = stack.pop();\n            push({ type: 'text', value });\n            block = stack[stack.length - 1];\n            continue;\n        }\n        /**\n         * Quotes: '|\"|`\n         */\n        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n            let open = value;\n            let next;\n            if (options.keepQuotes !== true) {\n                value = '';\n            }\n            while (index < length && (next = advance())) {\n                if (next === CHAR_BACKSLASH) {\n                    value += next + advance();\n                    continue;\n                }\n                if (next === open) {\n                    if (options.keepQuotes === true)\n                        value += next;\n                    break;\n                }\n                value += next;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Left curly brace: '{'\n         */\n        if (value === CHAR_LEFT_CURLY_BRACE) {\n            depth++;\n            let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n            let brace = {\n                type: 'brace',\n                open: true,\n                close: false,\n                dollar,\n                depth,\n                commas: 0,\n                ranges: 0,\n                nodes: []\n            };\n            block = push(brace);\n            stack.push(block);\n            push({ type: 'open', value });\n            continue;\n        }\n        /**\n         * Right curly brace: '}'\n         */\n        if (value === CHAR_RIGHT_CURLY_BRACE) {\n            if (block.type !== 'brace') {\n                push({ type: 'text', value });\n                continue;\n            }\n            let type = 'close';\n            block = stack.pop();\n            block.close = true;\n            push({ type, value });\n            depth--;\n            block = stack[stack.length - 1];\n            continue;\n        }\n        /**\n         * Comma: ','\n         */\n        if (value === CHAR_COMMA && depth > 0) {\n            if (block.ranges > 0) {\n                block.ranges = 0;\n                let open = block.nodes.shift();\n                block.nodes = [open, { type: 'text', value: stringify(block) }];\n            }\n            push({ type: 'comma', value });\n            block.commas++;\n            continue;\n        }\n        /**\n         * Dot: '.'\n         */\n        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n            let siblings = block.nodes;\n            if (depth === 0 || siblings.length === 0) {\n                push({ type: 'text', value });\n                continue;\n            }\n            if (prev.type === 'dot') {\n                block.range = [];\n                prev.value += value;\n                prev.type = 'range';\n                if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n                    block.invalid = true;\n                    block.ranges = 0;\n                    prev.type = 'text';\n                    continue;\n                }\n                block.ranges++;\n                block.args = [];\n                continue;\n            }\n            if (prev.type === 'range') {\n                siblings.pop();\n                let before = siblings[siblings.length - 1];\n                before.value += prev.value + value;\n                prev = before;\n                block.ranges--;\n                continue;\n            }\n            push({ type: 'dot', value });\n            continue;\n        }\n        /**\n         * Text\n         */\n        push({ type: 'text', value });\n    }\n    // Mark imbalanced braces and brackets as invalid\n    do {\n        block = stack.pop();\n        if (block.type !== 'root') {\n            block.nodes.forEach(node => {\n                if (!node.nodes) {\n                    if (node.type === 'open')\n                        node.isOpen = true;\n                    if (node.type === 'close')\n                        node.isClose = true;\n                    if (!node.nodes)\n                        node.type = 'text';\n                    node.invalid = true;\n                }\n            });\n            // get the location of the block on parent.nodes (block's siblings)\n            let parent = stack[stack.length - 1];\n            let index = parent.nodes.indexOf(block);\n            // replace the (invalid) block with it's nodes\n            parent.nodes.splice(index, 1, ...block.nodes);\n        }\n    } while (stack.length > 0);\n    push({ type: 'eos' });\n    return ast;\n};\nvar parse_1 = parse;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\nconst braces = (input, options = {}) => {\n    let output = [];\n    if (Array.isArray(input)) {\n        for (let pattern of input) {\n            let result = braces.create(pattern, options);\n            if (Array.isArray(result)) {\n                output.push(...result);\n            }\n            else {\n                output.push(result);\n            }\n        }\n    }\n    else {\n        output = [].concat(braces.create(input, options));\n    }\n    if (options && options.expand === true && options.nodupes === true) {\n        output = [...new Set(output)];\n    }\n    return output;\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\nbraces.parse = (input, options = {}) => parse_1(input, options);\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.stringify = (input, options = {}) => {\n    if (typeof input === 'string') {\n        return stringify(braces.parse(input, options), options);\n    }\n    return stringify(input, options);\n};\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.compile = (input, options = {}) => {\n    if (typeof input === 'string') {\n        input = braces.parse(input, options);\n    }\n    return compile_1(input, options);\n};\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.expand = (input, options = {}) => {\n    if (typeof input === 'string') {\n        input = braces.parse(input, options);\n    }\n    let result = expand_1(input, options);\n    // filter out empty strings if specified\n    if (options.noempty === true) {\n        result = result.filter(Boolean);\n    }\n    // filter out duplicates if specified\n    if (options.nodupes === true) {\n        result = [...new Set(result)];\n    }\n    return result;\n};\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.create = (input, options = {}) => {\n    if (input === '' || input.length < 3) {\n        return [input];\n    }\n    return options.expand !== true\n        ? braces.compile(input, options)\n        : braces.expand(input, options);\n};\n/**\n * Expose \"braces\"\n */\nvar braces_1 = braces;\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n/**\n * Posix glob regex\n */\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst POSIX_CHARS = {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    QMARK_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    QMARK,\n    END_ANCHOR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n};\n/**\n * Windows glob regex\n */\nconst WINDOWS_CHARS = Object.assign({}, POSIX_CHARS, { SLASH_LITERAL: `[${WIN_SLASH}]`, QMARK: WIN_NO_SLASH, STAR: `${WIN_NO_SLASH}*?`, DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`, NO_DOT: `(?!${DOT_LITERAL})`, NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`, NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`, NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`, QMARK_NO_DOT: `[^.${WIN_SLASH}]`, START_ANCHOR: `(?:^|[${WIN_SLASH}])`, END_ANCHOR: `(?:[${WIN_SLASH}]|$)` });\n/**\n * POSIX Bracket Regex\n */\nconst POSIX_REGEX_SOURCE = {\n    alnum: 'a-zA-Z0-9',\n    alpha: 'a-zA-Z',\n    ascii: '\\\\x00-\\\\x7F',\n    blank: ' \\\\t',\n    cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n    digit: '0-9',\n    graph: '\\\\x21-\\\\x7E',\n    lower: 'a-z',\n    print: '\\\\x20-\\\\x7E ',\n    punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n    space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n    upper: 'A-Z',\n    word: 'A-Za-z0-9_',\n    xdigit: 'A-Fa-f0-9'\n};\nvar constants$1 = {\n    MAX_LENGTH: 1024 * 64,\n    POSIX_REGEX_SOURCE,\n    // regular expressions\n    REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n    REGEX_NON_SPECIAL_CHAR: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n    REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n    REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n    // Replace globs with equivalent patterns to reduce parsing time.\n    REPLACEMENTS: {\n        '***': '*',\n        '**/**': '**',\n        '**/**/**': '**'\n    },\n    // Digits\n    CHAR_0: 48,\n    CHAR_9: 57,\n    // Alphabet chars.\n    CHAR_UPPERCASE_A: 65,\n    CHAR_LOWERCASE_A: 97,\n    CHAR_UPPERCASE_Z: 90,\n    CHAR_LOWERCASE_Z: 122,\n    CHAR_LEFT_PARENTHESES: 40,\n    CHAR_RIGHT_PARENTHESES: 41,\n    CHAR_ASTERISK: 42,\n    // Non-alphabetic chars.\n    CHAR_AMPERSAND: 38,\n    CHAR_AT: 64,\n    CHAR_BACKWARD_SLASH: 92,\n    CHAR_CARRIAGE_RETURN: 13,\n    CHAR_CIRCUMFLEX_ACCENT: 94,\n    CHAR_COLON: 58,\n    CHAR_COMMA: 44,\n    CHAR_DOT: 46,\n    CHAR_DOUBLE_QUOTE: 34,\n    CHAR_EQUAL: 61,\n    CHAR_EXCLAMATION_MARK: 33,\n    CHAR_FORM_FEED: 12,\n    CHAR_FORWARD_SLASH: 47,\n    CHAR_GRAVE_ACCENT: 96,\n    CHAR_HASH: 35,\n    CHAR_HYPHEN_MINUS: 45,\n    CHAR_LEFT_ANGLE_BRACKET: 60,\n    CHAR_LEFT_CURLY_BRACE: 123,\n    CHAR_LEFT_SQUARE_BRACKET: 91,\n    CHAR_LINE_FEED: 10,\n    CHAR_NO_BREAK_SPACE: 160,\n    CHAR_PERCENT: 37,\n    CHAR_PLUS: 43,\n    CHAR_QUESTION_MARK: 63,\n    CHAR_RIGHT_ANGLE_BRACKET: 62,\n    CHAR_RIGHT_CURLY_BRACE: 125,\n    CHAR_RIGHT_SQUARE_BRACKET: 93,\n    CHAR_SEMICOLON: 59,\n    CHAR_SINGLE_QUOTE: 39,\n    CHAR_SPACE: 32,\n    CHAR_TAB: 9,\n    CHAR_UNDERSCORE: 95,\n    CHAR_VERTICAL_LINE: 124,\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n    SEP: path.sep,\n    /**\n     * Create EXTGLOB_CHARS\n     */\n    extglobChars(chars) {\n        return {\n            '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n            '?': { type: 'qmark', open: '(?:', close: ')?' },\n            '+': { type: 'plus', open: '(?:', close: ')+' },\n            '*': { type: 'star', open: '(?:', close: ')*' },\n            '@': { type: 'at', open: '(?:', close: ')' }\n        };\n    },\n    /**\n     * Create GLOB_CHARS\n     */\n    globChars(win32) {\n        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n    }\n};\n\nvar utils$1 = createCommonjsModule(function (module, exports) {\n    const win32 = process.platform === 'win32';\n    const { REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL, REGEX_REMOVE_BACKSLASH } = constants$1;\n    exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n    exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n    exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n    exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n    exports.toPosixSlashes = str => str.replace(/\\\\/g, '/');\n    exports.removeBackslashes = str => {\n        return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n            return match === '\\\\' ? '' : match;\n        });\n    };\n    exports.supportsLookbehinds = () => {\n        let segs = process.version.slice(1).split('.');\n        if (segs.length === 3 && +segs[0] >= 9 || (+segs[0] === 8 && +segs[1] >= 10)) {\n            return true;\n        }\n        return false;\n    };\n    exports.isWindows = options => {\n        if (options && typeof options.windows === 'boolean') {\n            return options.windows;\n        }\n        return win32 === true || path.sep === '\\\\';\n    };\n    exports.escapeLast = (input, char, lastIdx) => {\n        let idx = input.lastIndexOf(char, lastIdx);\n        if (idx === -1)\n            return input;\n        if (input[idx - 1] === '\\\\')\n            return exports.escapeLast(input, char, idx - 1);\n        return input.slice(0, idx) + '\\\\' + input.slice(idx);\n    };\n});\nvar utils_1$1 = utils$1.isObject;\nvar utils_2$1 = utils$1.hasRegexChars;\nvar utils_3$1 = utils$1.isRegexChar;\nvar utils_4$1 = utils$1.escapeRegex;\nvar utils_5$1 = utils$1.toPosixSlashes;\nvar utils_6$1 = utils$1.removeBackslashes;\nvar utils_7$1 = utils$1.supportsLookbehinds;\nvar utils_8$1 = utils$1.isWindows;\nvar utils_9$1 = utils$1.escapeLast;\n\nconst { CHAR_ASTERISK, /* * */ CHAR_AT, /* @ */ CHAR_BACKWARD_SLASH, /* \\ */ CHAR_COMMA: CHAR_COMMA$1, /* , */ CHAR_DOT: CHAR_DOT$1, /* . */ CHAR_EXCLAMATION_MARK, /* ! */ CHAR_FORWARD_SLASH, /* / */ CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1, /* { */ CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1, /* ( */ CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1, /* [ */ CHAR_PLUS, /* + */ CHAR_QUESTION_MARK, /* ? */ CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1, /* } */ CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1, /* ) */ CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1 /* ] */ } = constants$1;\nconst isPathSeparator = code => {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\nvar scan = (input, options) => {\n    let opts = options || {};\n    let length = input.length - 1;\n    let index = -1;\n    let start = 0;\n    let lastIndex = 0;\n    let isGlob = false;\n    let backslashes = false;\n    let negated = false;\n    let braces = 0;\n    let prev;\n    let code;\n    let braceEscaped = false;\n    let eos = () => index >= length;\n    let advance = () => {\n        prev = code;\n        return input.charCodeAt(++index);\n    };\n    while (index < length) {\n        code = advance();\n        let next;\n        if (code === CHAR_BACKWARD_SLASH) {\n            backslashes = true;\n            next = advance();\n            if (next === CHAR_LEFT_CURLY_BRACE$1) {\n                braceEscaped = true;\n            }\n            continue;\n        }\n        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {\n            braces++;\n            while (!eos() && (next = advance())) {\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = true;\n                    next = advance();\n                    continue;\n                }\n                if (next === CHAR_LEFT_CURLY_BRACE$1) {\n                    braces++;\n                    continue;\n                }\n                if (!braceEscaped && next === CHAR_DOT$1 && (next = advance()) === CHAR_DOT$1) {\n                    isGlob = true;\n                    break;\n                }\n                if (!braceEscaped && next === CHAR_COMMA$1) {\n                    isGlob = true;\n                    break;\n                }\n                if (next === CHAR_RIGHT_CURLY_BRACE$1) {\n                    braces--;\n                    if (braces === 0) {\n                        braceEscaped = false;\n                        break;\n                    }\n                }\n            }\n        }\n        if (code === CHAR_FORWARD_SLASH) {\n            if (prev === CHAR_DOT$1 && index === (start + 1)) {\n                start += 2;\n                continue;\n            }\n            lastIndex = index + 1;\n            continue;\n        }\n        if (code === CHAR_ASTERISK) {\n            isGlob = true;\n            break;\n        }\n        if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {\n            isGlob = true;\n            break;\n        }\n        if (code === CHAR_LEFT_SQUARE_BRACKET$1) {\n            while (!eos() && (next = advance())) {\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = true;\n                    next = advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {\n                    isGlob = true;\n                    break;\n                }\n            }\n        }\n        let isExtglobChar = code === CHAR_PLUS\n            || code === CHAR_AT\n            || code === CHAR_EXCLAMATION_MARK;\n        if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES$1) {\n            isGlob = true;\n            break;\n        }\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n            negated = true;\n            start++;\n            continue;\n        }\n        if (code === CHAR_LEFT_PARENTHESES$1) {\n            while (!eos() && (next = advance())) {\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = true;\n                    next = advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_PARENTHESES$1) {\n                    isGlob = true;\n                    break;\n                }\n            }\n        }\n        if (isGlob) {\n            break;\n        }\n    }\n    let prefix = '';\n    let orig = input;\n    let base = input;\n    let glob = '';\n    if (start > 0) {\n        prefix = input.slice(0, start);\n        input = input.slice(start);\n        lastIndex -= start;\n    }\n    if (base && isGlob === true && lastIndex > 0) {\n        base = input.slice(0, lastIndex);\n        glob = input.slice(lastIndex);\n    }\n    else if (isGlob === true) {\n        base = '';\n        glob = input;\n    }\n    else {\n        base = input;\n    }\n    if (base && base !== '' && base !== '/' && base !== input) {\n        if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n            base = base.slice(0, -1);\n        }\n    }\n    if (opts.unescape === true) {\n        if (glob)\n            glob = utils$1.removeBackslashes(glob);\n        if (base && backslashes === true) {\n            base = utils$1.removeBackslashes(base);\n        }\n    }\n    return { prefix, input: orig, base, glob, negated, isGlob };\n};\n\n/**\n * Constants\n */\nconst { MAX_LENGTH: MAX_LENGTH$1, POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1, REGEX_NON_SPECIAL_CHAR, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants$1;\n/**\n * Helpers\n */\nconst expandRange = (args, options) => {\n    if (typeof options.expandRange === 'function') {\n        return options.expandRange(...args, options);\n    }\n    args.sort();\n    let value = `[${args.join('-')}]`;\n    try {\n    }\n    catch (ex) {\n        return args.map(v => utils$1.escapeRegex(v)).join('..');\n    }\n    return value;\n};\nconst negate = state => {\n    let count = 1;\n    while (state.peek() === '!' && (state.peek(2) !== '(' || state.peek(3) === '?')) {\n        state.advance();\n        state.start++;\n        count++;\n    }\n    if (count % 2 === 0) {\n        return false;\n    }\n    state.negated = true;\n    state.start++;\n    return true;\n};\n/**\n * Create the message for a syntax error\n */\nconst syntaxError = (type, char) => {\n    return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\nconst parse$1 = (input, options) => {\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    input = REPLACEMENTS[input] || input;\n    let opts = Object.assign({}, options);\n    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n    let len = input.length;\n    if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    let bos = { type: 'bos', value: '', output: opts.prepend || '' };\n    let tokens = [bos];\n    let capture = opts.capture ? '' : '?:';\n    let win32 = utils$1.isWindows(options);\n    // create constants based on platform, for windows or posix\n    const PLATFORM_CHARS = constants$1.globChars(win32);\n    const EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS);\n    const { DOT_LITERAL, PLUS_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK, QMARK_NO_DOT, STAR, START_ANCHOR } = PLATFORM_CHARS;\n    const globstar = (opts) => {\n        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    let nodot = opts.dot ? '' : NO_DOT;\n    let star = opts.bash === true ? globstar(opts) : STAR;\n    let qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n    if (opts.capture) {\n        star = `(${star})`;\n    }\n    // minimatch options support\n    if (typeof opts.noext === 'boolean') {\n        opts.noextglob = opts.noext;\n    }\n    let state = {\n        index: -1,\n        start: 0,\n        consumed: '',\n        output: '',\n        backtrack: false,\n        brackets: 0,\n        braces: 0,\n        parens: 0,\n        quotes: 0,\n        tokens\n    };\n    let extglobs = [];\n    let stack = [];\n    let prev = bos;\n    let value;\n    /**\n     * Tokenizing helpers\n     */\n    const eos = () => state.index === len - 1;\n    const peek = state.peek = (n = 1) => input[state.index + n];\n    const advance = state.advance = () => input[++state.index];\n    const append = token => {\n        state.output += token.output != null ? token.output : token.value;\n        state.consumed += token.value || '';\n    };\n    const increment = type => {\n        state[type]++;\n        stack.push(type);\n    };\n    const decrement = type => {\n        state[type]--;\n        stack.pop();\n    };\n    /**\n     * Push tokens onto the tokens array. This helper speeds up\n     * tokenizing by 1) helping us avoid backtracking as much as possible,\n     * and 2) helping us avoid creating extra tokens when consecutive\n     * characters are plain text. This improves performance and simplifies\n     * lookbehinds.\n     */\n    const push = tok => {\n        if (prev.type === 'globstar') {\n            let isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n            let isExtglob = extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n            if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n                state.output = state.output.slice(0, -prev.output.length);\n                prev.type = 'star';\n                prev.value = '*';\n                prev.output = star;\n                state.output += prev.output;\n            }\n        }\n        if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n            extglobs[extglobs.length - 1].inner += tok.value;\n        }\n        if (tok.value || tok.output)\n            append(tok);\n        if (prev && prev.type === 'text' && tok.type === 'text') {\n            prev.value += tok.value;\n            return;\n        }\n        tok.prev = prev;\n        tokens.push(tok);\n        prev = tok;\n    };\n    const extglobOpen = (type, value) => {\n        let token = Object.assign({}, EXTGLOB_CHARS[value], { conditions: 1, inner: '' });\n        token.prev = prev;\n        token.parens = state.parens;\n        token.output = state.output;\n        let output = (opts.capture ? '(' : '') + token.open;\n        push({ type, value, output: state.output ? '' : ONE_CHAR });\n        push({ type: 'paren', extglob: true, value: advance(), output });\n        increment('parens');\n        extglobs.push(token);\n    };\n    const extglobClose = token => {\n        let output = token.close + (opts.capture ? ')' : '');\n        if (token.type === 'negate') {\n            let extglobStar = star;\n            if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n                extglobStar = globstar(opts);\n            }\n            if (extglobStar !== star || eos() || /^\\)+$/.test(input.slice(state.index + 1))) {\n                output = token.close = ')$))' + extglobStar;\n            }\n            if (token.prev.type === 'bos' && eos()) {\n                state.negatedExtglob = true;\n            }\n        }\n        push({ type: 'paren', extglob: true, value, output });\n        decrement('parens');\n    };\n    if (opts.fastpaths !== false && !/(^[*!]|[/{[()\\]}\"])/.test(input)) {\n        let backslashes = false;\n        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n            if (first === '\\\\') {\n                backslashes = true;\n                return m;\n            }\n            if (first === '?') {\n                if (esc) {\n                    return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n                }\n                if (index === 0) {\n                    return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n                }\n                return QMARK.repeat(chars.length);\n            }\n            if (first === '.') {\n                return DOT_LITERAL.repeat(chars.length);\n            }\n            if (first === '*') {\n                if (esc) {\n                    return esc + first + (rest ? star : '');\n                }\n                return star;\n            }\n            return esc ? m : '\\\\' + m;\n        });\n        if (backslashes === true) {\n            if (opts.unescape === true) {\n                output = output.replace(/\\\\/g, '');\n            }\n            else {\n                output = output.replace(/\\\\+/g, m => {\n                    return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n                });\n            }\n        }\n        state.output = output;\n        return state;\n    }\n    /**\n     * Tokenize input until we reach end-of-string\n     */\n    while (!eos()) {\n        value = advance();\n        if (value === '\\u0000') {\n            continue;\n        }\n        /**\n         * Escaped characters\n         */\n        if (value === '\\\\') {\n            let next = peek();\n            if (next === '/' && opts.bash !== true) {\n                continue;\n            }\n            if (next === '.' || next === ';') {\n                continue;\n            }\n            if (!next) {\n                value += '\\\\';\n                push({ type: 'text', value });\n                continue;\n            }\n            // collapse slashes to reduce potential for exploits\n            let match = /^\\\\+/.exec(input.slice(state.index + 1));\n            let slashes = 0;\n            if (match && match[0].length > 2) {\n                slashes = match[0].length;\n                state.index += slashes;\n                if (slashes % 2 !== 0) {\n                    value += '\\\\';\n                }\n            }\n            if (opts.unescape === true) {\n                value = advance() || '';\n            }\n            else {\n                value += advance() || '';\n            }\n            if (state.brackets === 0) {\n                push({ type: 'text', value });\n                continue;\n            }\n        }\n        /**\n         * If we're inside a regex character class, continue\n         * until we reach the closing bracket.\n         */\n        if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n            if (opts.posix !== false && value === ':') {\n                let inner = prev.value.slice(1);\n                if (inner.includes('[')) {\n                    prev.posix = true;\n                    if (inner.includes(':')) {\n                        let idx = prev.value.lastIndexOf('[');\n                        let pre = prev.value.slice(0, idx);\n                        let rest = prev.value.slice(idx + 2);\n                        let posix = POSIX_REGEX_SOURCE$1[rest];\n                        if (posix) {\n                            prev.value = pre + posix;\n                            state.backtrack = true;\n                            advance();\n                            if (!bos.output && tokens.indexOf(prev) === 1) {\n                                bos.output = ONE_CHAR;\n                            }\n                            continue;\n                        }\n                    }\n                }\n            }\n            if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n                value = '\\\\' + value;\n            }\n            if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n                value = '\\\\' + value;\n            }\n            if (opts.posix === true && value === '!' && prev.value === '[') {\n                value = '^';\n            }\n            prev.value += value;\n            append({ value });\n            continue;\n        }\n        /**\n         * If we're inside a quoted string, continue\n         * until we reach the closing double quote.\n         */\n        if (state.quotes === 1 && value !== '\"') {\n            value = utils$1.escapeRegex(value);\n            prev.value += value;\n            append({ value });\n            continue;\n        }\n        /**\n         * Double quotes\n         */\n        if (value === '\"') {\n            state.quotes = state.quotes === 1 ? 0 : 1;\n            if (opts.keepQuotes === true) {\n                push({ type: 'text', value });\n            }\n            continue;\n        }\n        /**\n         * Parentheses\n         */\n        if (value === '(') {\n            push({ type: 'paren', value });\n            increment('parens');\n            continue;\n        }\n        if (value === ')') {\n            if (state.parens === 0 && opts.strictBrackets === true) {\n                throw new SyntaxError(syntaxError('opening', '('));\n            }\n            let extglob = extglobs[extglobs.length - 1];\n            if (extglob && state.parens === extglob.parens + 1) {\n                extglobClose(extglobs.pop());\n                continue;\n            }\n            push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n            decrement('parens');\n            continue;\n        }\n        /**\n         * Brackets\n         */\n        if (value === '[') {\n            if (opts.nobracket === true || !input.slice(state.index + 1).includes(']')) {\n                if (opts.nobracket !== true && opts.strictBrackets === true) {\n                    throw new SyntaxError(syntaxError('closing', ']'));\n                }\n                value = '\\\\' + value;\n            }\n            else {\n                increment('brackets');\n            }\n            push({ type: 'bracket', value });\n            continue;\n        }\n        if (value === ']') {\n            if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n                push({ type: 'text', value, output: '\\\\' + value });\n                continue;\n            }\n            if (state.brackets === 0) {\n                if (opts.strictBrackets === true) {\n                    throw new SyntaxError(syntaxError('opening', '['));\n                }\n                push({ type: 'text', value, output: '\\\\' + value });\n                continue;\n            }\n            decrement('brackets');\n            let prevValue = prev.value.slice(1);\n            if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n                value = '/' + value;\n            }\n            prev.value += value;\n            append({ value });\n            // when literal brackets are explicitly disabled\n            // assume we should match with a regex character class\n            if (opts.literalBrackets === false || utils$1.hasRegexChars(prevValue)) {\n                continue;\n            }\n            let escaped = utils$1.escapeRegex(prev.value);\n            state.output = state.output.slice(0, -prev.value.length);\n            // when literal brackets are explicitly enabled\n            // assume we should escape the brackets to match literal characters\n            if (opts.literalBrackets === true) {\n                state.output += escaped;\n                prev.value = escaped;\n                continue;\n            }\n            // when the user specifies nothing, try to match both\n            prev.value = `(${capture}${escaped}|${prev.value})`;\n            state.output += prev.value;\n            continue;\n        }\n        /**\n         * Braces\n         */\n        if (value === '{' && opts.nobrace !== true) {\n            push({ type: 'brace', value, output: '(' });\n            increment('braces');\n            continue;\n        }\n        if (value === '}') {\n            if (opts.nobrace === true || state.braces === 0) {\n                push({ type: 'text', value, output: '\\\\' + value });\n                continue;\n            }\n            let output = ')';\n            if (state.dots === true) {\n                let arr = tokens.slice();\n                let range = [];\n                for (let i = arr.length - 1; i >= 0; i--) {\n                    tokens.pop();\n                    if (arr[i].type === 'brace') {\n                        break;\n                    }\n                    if (arr[i].type !== 'dots') {\n                        range.unshift(arr[i].value);\n                    }\n                }\n                output = expandRange(range, opts);\n                state.backtrack = true;\n            }\n            push({ type: 'brace', value, output });\n            decrement('braces');\n            continue;\n        }\n        /**\n         * Pipes\n         */\n        if (value === '|') {\n            if (extglobs.length > 0) {\n                extglobs[extglobs.length - 1].conditions++;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Commas\n         */\n        if (value === ',') {\n            let output = value;\n            if (state.braces > 0 && stack[stack.length - 1] === 'braces') {\n                output = '|';\n            }\n            push({ type: 'comma', value, output });\n            continue;\n        }\n        /**\n         * Slashes\n         */\n        if (value === '/') {\n            // if the beginning of the glob is \"./\", advance the start\n            // to the current index, and don't add the \"./\" characters\n            // to the state. This greatly simplifies lookbehinds when\n            // checking for BOS characters like \"!\" and \".\" (not \"./\")\n            if (prev.type === 'dot' && state.index === 1) {\n                state.start = state.index + 1;\n                state.consumed = '';\n                state.output = '';\n                tokens.pop();\n                prev = bos; // reset \"prev\" to the first token\n                continue;\n            }\n            push({ type: 'slash', value, output: SLASH_LITERAL });\n            continue;\n        }\n        /**\n         * Dots\n         */\n        if (value === '.') {\n            if (state.braces > 0 && prev.type === 'dot') {\n                if (prev.value === '.')\n                    prev.output = DOT_LITERAL;\n                prev.type = 'dots';\n                prev.output += value;\n                prev.value += value;\n                state.dots = true;\n                continue;\n            }\n            push({ type: 'dot', value, output: DOT_LITERAL });\n            continue;\n        }\n        /**\n         * Question marks\n         */\n        if (value === '?') {\n            if (prev && prev.type === 'paren') {\n                let next = peek();\n                let output = value;\n                if (next === '<' && !utils$1.supportsLookbehinds()) {\n                    throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n                }\n                if (prev.value === '(' && !/[!=<:]/.test(next) || (next === '<' && !/[!=]/.test(peek(2)))) {\n                    output = '\\\\' + value;\n                }\n                push({ type: 'text', value, output });\n                continue;\n            }\n            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n                extglobOpen('qmark', value);\n                continue;\n            }\n            if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n                push({ type: 'qmark', value, output: QMARK_NO_DOT });\n                continue;\n            }\n            push({ type: 'qmark', value, output: QMARK });\n            continue;\n        }\n        /**\n         * Exclamation\n         */\n        if (value === '!') {\n            if (opts.noextglob !== true && peek() === '(') {\n                if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n                    extglobOpen('negate', value);\n                    continue;\n                }\n            }\n            if (opts.nonegate !== true && state.index === 0) {\n                negate(state);\n                continue;\n            }\n        }\n        /**\n         * Plus\n         */\n        if (value === '+') {\n            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n                extglobOpen('plus', value);\n                continue;\n            }\n            if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) {\n                let output = prev.extglob === true ? '\\\\' + value : value;\n                push({ type: 'plus', value, output });\n                continue;\n            }\n            // use regex behavior inside parens\n            if (state.parens > 0 && opts.regex !== false) {\n                push({ type: 'plus', value });\n                continue;\n            }\n            push({ type: 'plus', value: PLUS_LITERAL });\n            continue;\n        }\n        /**\n         * Plain text\n         */\n        if (value === '@') {\n            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n                push({ type: 'at', value, output: '' });\n                continue;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Plain text\n         */\n        if (value !== '*') {\n            if (value === '$' || value === '^') {\n                value = '\\\\' + value;\n            }\n            let match = REGEX_NON_SPECIAL_CHAR.exec(input.slice(state.index + 1));\n            if (match) {\n                value += match[0];\n                state.index += match[0].length;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Stars\n         */\n        if (prev && (prev.type === 'globstar' || prev.star === true)) {\n            prev.type = 'star';\n            prev.star = true;\n            prev.value += value;\n            prev.output = star;\n            state.backtrack = true;\n            state.consumed += value;\n            continue;\n        }\n        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n            extglobOpen('star', value);\n            continue;\n        }\n        if (prev.type === 'star') {\n            if (opts.noglobstar === true) {\n                state.consumed += value;\n                continue;\n            }\n            let prior = prev.prev;\n            let before = prior.prev;\n            let isStart = prior.type === 'slash' || prior.type === 'bos';\n            let afterStar = before && (before.type === 'star' || before.type === 'globstar');\n            if (opts.bash === true && (!isStart || (!eos() && peek() !== '/'))) {\n                push({ type: 'star', value, output: '' });\n                continue;\n            }\n            let isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n            let isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n            if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n                push({ type: 'star', value, output: '' });\n                continue;\n            }\n            // strip consecutive `/**/`\n            while (input.slice(state.index + 1, state.index + 4) === '/**') {\n                let after = input[state.index + 4];\n                if (after && after !== '/') {\n                    break;\n                }\n                state.consumed += '/**';\n                state.index += 3;\n            }\n            if (prior.type === 'bos' && eos()) {\n                prev.type = 'globstar';\n                prev.value += value;\n                prev.output = globstar(opts);\n                state.output = prev.output;\n                state.consumed += value;\n                continue;\n            }\n            if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n                state.output = state.output.slice(0, -(prior.output + prev.output).length);\n                prior.output = '(?:' + prior.output;\n                prev.type = 'globstar';\n                prev.output = globstar(opts) + '|$)';\n                prev.value += value;\n                state.output += prior.output + prev.output;\n                state.consumed += value;\n                continue;\n            }\n            let next = peek();\n            if (prior.type === 'slash' && prior.prev.type !== 'bos' && next === '/') {\n                let end = peek(2) !== void 0 ? '|$' : '';\n                state.output = state.output.slice(0, -(prior.output + prev.output).length);\n                prior.output = '(?:' + prior.output;\n                prev.type = 'globstar';\n                prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n                prev.value += value;\n                state.output += prior.output + prev.output;\n                state.consumed += value + advance();\n                push({ type: 'slash', value, output: '' });\n                continue;\n            }\n            if (prior.type === 'bos' && next === '/') {\n                prev.type = 'globstar';\n                prev.value += value;\n                prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n                state.output = prev.output;\n                state.consumed += value + advance();\n                push({ type: 'slash', value, output: '' });\n                continue;\n            }\n            // remove single star from output\n            state.output = state.output.slice(0, -prev.output.length);\n            // reset previous token to globstar\n            prev.type = 'globstar';\n            prev.output = globstar(opts);\n            prev.value += value;\n            // reset output with globstar\n            state.output += prev.output;\n            state.consumed += value;\n            continue;\n        }\n        let token = { type: 'star', value, output: star };\n        if (opts.bash === true) {\n            token.output = '.*?';\n            if (prev.type === 'bos' || prev.type === 'slash') {\n                token.output = nodot + token.output;\n            }\n            push(token);\n            continue;\n        }\n        if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n            token.output = value;\n            push(token);\n            continue;\n        }\n        if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n            if (prev.type === 'dot') {\n                state.output += NO_DOT_SLASH;\n                prev.output += NO_DOT_SLASH;\n            }\n            else if (opts.dot === true) {\n                state.output += NO_DOTS_SLASH;\n                prev.output += NO_DOTS_SLASH;\n            }\n            else {\n                state.output += nodot;\n                prev.output += nodot;\n            }\n            if (peek() !== '*') {\n                state.output += ONE_CHAR;\n                prev.output += ONE_CHAR;\n            }\n        }\n        push(token);\n    }\n    while (state.brackets > 0) {\n        if (opts.strictBrackets === true)\n            throw new SyntaxError(syntaxError('closing', ']'));\n        state.output = utils$1.escapeLast(state.output, '[');\n        decrement('brackets');\n    }\n    while (state.parens > 0) {\n        if (opts.strictBrackets === true)\n            throw new SyntaxError(syntaxError('closing', ')'));\n        state.output = utils$1.escapeLast(state.output, '(');\n        decrement('parens');\n    }\n    while (state.braces > 0) {\n        if (opts.strictBrackets === true)\n            throw new SyntaxError(syntaxError('closing', '}'));\n        state.output = utils$1.escapeLast(state.output, '{');\n        decrement('braces');\n    }\n    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n        push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n    }\n    // rebuild the output if we had to backtrack at any point\n    if (state.backtrack === true) {\n        state.output = '';\n        for (let token of state.tokens) {\n            state.output += token.output != null ? token.output : token.value;\n            if (token.suffix) {\n                state.output += token.suffix;\n            }\n        }\n    }\n    return state;\n};\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\nparse$1.fastpaths = (input, options) => {\n    let opts = Object.assign({}, options);\n    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n    let len = input.length;\n    if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    input = REPLACEMENTS[input] || input;\n    let win32 = utils$1.isWindows(options);\n    // create constants based on platform, for windows or posix\n    const { DOT_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOTS_SLASH, STAR, START_ANCHOR } = constants$1.globChars(win32);\n    let capture = opts.capture ? '' : '?:';\n    let star = opts.bash === true ? '.*?' : STAR;\n    let nodot = opts.dot ? NO_DOTS : NO_DOT;\n    let slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n    if (opts.capture) {\n        star = `(${star})`;\n    }\n    const globstar = (opts) => {\n        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    const create = str => {\n        switch (str) {\n            case '*':\n                return `${nodot}${ONE_CHAR}${star}`;\n            case '.*':\n                return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case '*.*':\n                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case '*/*':\n                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n            case '**':\n                return nodot + globstar(opts);\n            case '**/*':\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n            case '**/*.*':\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case '**/.*':\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n            default: {\n                let match = /^(.*?)\\.(\\w+)$/.exec(str);\n                if (!match)\n                    return;\n                let source = create(match[1], options);\n                if (!source)\n                    return;\n                return source + DOT_LITERAL + match[2];\n            }\n        }\n    };\n    let output = create(input);\n    if (output && opts.strictSlashes !== true) {\n        output += `${SLASH_LITERAL}?`;\n    }\n    return output;\n};\nvar parse_1$1 = parse$1;\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\nconst picomatch = (glob, options, returnState = false) => {\n    if (Array.isArray(glob)) {\n        let fns = glob.map(input => picomatch(input, options, returnState));\n        return str => {\n            for (let isMatch of fns) {\n                let state = isMatch(str);\n                if (state)\n                    return state;\n            }\n            return false;\n        };\n    }\n    if (typeof glob !== 'string' || glob === '') {\n        throw new TypeError('Expected pattern to be a non-empty string');\n    }\n    let opts = options || {};\n    let posix = utils$1.isWindows(options);\n    let regex = picomatch.makeRe(glob, options, false, true);\n    let state = regex.state;\n    delete regex.state;\n    let isIgnored = () => false;\n    if (opts.ignore) {\n        let ignoreOpts = Object.assign({}, options, { ignore: null, onMatch: null, onResult: null });\n        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n    }\n    const matcher = (input, returnObject = false) => {\n        let { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n        let result = { glob, state, regex, posix, input, output, match, isMatch };\n        if (typeof opts.onResult === 'function') {\n            opts.onResult(result);\n        }\n        if (isMatch === false) {\n            result.isMatch = false;\n            return returnObject ? result : false;\n        }\n        if (isIgnored(input)) {\n            if (typeof opts.onIgnore === 'function') {\n                opts.onIgnore(result);\n            }\n            result.isMatch = false;\n            return returnObject ? result : false;\n        }\n        if (typeof opts.onMatch === 'function') {\n            opts.onMatch(result);\n        }\n        return returnObject ? result : true;\n    };\n    if (returnState) {\n        matcher.state = state;\n    }\n    return matcher;\n};\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected input to be a string');\n    }\n    if (input === '') {\n        return { isMatch: false, output: '' };\n    }\n    let opts = options || {};\n    let format = opts.format || (posix ? utils$1.toPosixSlashes : null);\n    let match = input === glob;\n    let output = (match && format) ? format(input) : input;\n    if (match === false) {\n        output = format ? format(input) : input;\n        match = output === glob;\n    }\n    if (match === false || opts.capture === true) {\n        if (opts.matchBase === true || opts.basename === true) {\n            match = picomatch.matchBase(input, regex, options, posix);\n        }\n        else {\n            match = regex.exec(output);\n        }\n    }\n    return { isMatch: !!match, match, output };\n};\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\npicomatch.matchBase = (input, glob, options, posix = utils$1.isWindows(options)) => {\n    let regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n    return regex.test(path.basename(input));\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(glob[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\npicomatch.parse = (glob, options) => parse_1$1(glob, options);\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * // { prefix: '!./',\n * //   input: '!./foo/*.js',\n * //   base: 'foo',\n * //   glob: '*.js',\n * //   negated: true,\n * //   isGlob: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\npicomatch.scan = (input, options) => scan(input, options);\n/**\n * Create a regular expression from a glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.makeRe(input[, options]);\n *\n * console.log(picomatch.makeRe('*.js'));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `input` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n    if (!input || typeof input !== 'string') {\n        throw new TypeError('Expected a non-empty string');\n    }\n    let opts = options || {};\n    let prepend = opts.contains ? '' : '^';\n    let append = opts.contains ? '' : '$';\n    let state = { negated: false, fastpaths: true };\n    let prefix = '';\n    let output;\n    if (input.startsWith('./')) {\n        input = input.slice(2);\n        prefix = state.prefix = './';\n    }\n    if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n        output = parse_1$1.fastpaths(input, options);\n    }\n    if (output === void 0) {\n        state = picomatch.parse(input, options);\n        state.prefix = prefix + (state.prefix || '');\n        output = state.output;\n    }\n    if (returnOutput === true) {\n        return output;\n    }\n    let source = `${prepend}(?:${output})${append}`;\n    if (state && state.negated === true) {\n        source = `^(?!${source}).*$`;\n    }\n    let regex = picomatch.toRegex(source, options);\n    if (returnState === true) {\n        regex.state = state;\n    }\n    return regex;\n};\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\npicomatch.toRegex = (source, options) => {\n    try {\n        let opts = options || {};\n        return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n    }\n    catch (err) {\n        if (options && options.debug === true)\n            throw err;\n        return /$^/;\n    }\n};\n/**\n * Picomatch constants.\n * @return {Object}\n */\npicomatch.constants = constants$1;\n/**\n * Expose \"picomatch\"\n */\nvar picomatch_1 = picomatch;\n\nvar picomatch$1 = picomatch_1;\n\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\nconst micromatch = (list, patterns, options) => {\n    patterns = [].concat(patterns);\n    list = [].concat(list);\n    let omit = new Set();\n    let keep = new Set();\n    let items = new Set();\n    let negatives = 0;\n    let onResult = state => {\n        items.add(state.output);\n        if (options && options.onResult) {\n            options.onResult(state);\n        }\n    };\n    for (let i = 0; i < patterns.length; i++) {\n        let isMatch = picomatch$1(String(patterns[i]), Object.assign({}, options, { onResult }), true);\n        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n        if (negated)\n            negatives++;\n        for (let item of list) {\n            let matched = isMatch(item, true);\n            let match = negated ? !matched.isMatch : matched.isMatch;\n            if (!match)\n                continue;\n            if (negated) {\n                omit.add(matched.output);\n            }\n            else {\n                omit.delete(matched.output);\n                keep.add(matched.output);\n            }\n        }\n    }\n    let result = negatives === patterns.length ? [...items] : [...keep];\n    let matches = result.filter(item => !omit.has(item));\n    if (options && matches.length === 0) {\n        if (options.failglob === true) {\n            throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n        }\n        if (options.nonull === true || options.nullglob === true) {\n            return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n        }\n    }\n    return matches;\n};\n/**\n * Backwards compatibility\n */\nmicromatch.match = micromatch;\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\nmicromatch.matcher = (pattern, options) => picomatch$1(pattern, options);\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);\n/**\n * Backwards compatibility\n */\nmicromatch.any = micromatch.isMatch;\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\nmicromatch.not = (list, patterns, options = {}) => {\n    patterns = [].concat(patterns).map(String);\n    let result = new Set();\n    let items = [];\n    let onResult = state => {\n        if (options.onResult)\n            options.onResult(state);\n        items.push(state.output);\n    };\n    let matches = micromatch(list, patterns, Object.assign({}, options, { onResult }));\n    for (let item of items) {\n        if (!matches.includes(item)) {\n            result.add(item);\n        }\n    }\n    return [...result];\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\nmicromatch.contains = (str, pattern, options) => {\n    if (typeof str !== 'string') {\n        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n    }\n    if (Array.isArray(pattern)) {\n        return pattern.some(p => micromatch.contains(str, p, options));\n    }\n    if (typeof pattern === 'string') {\n        if (isEmptyString(str) || isEmptyString(pattern)) {\n            return false;\n        }\n        if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n            return true;\n        }\n    }\n    return micromatch.isMatch(str, pattern, Object.assign({}, options, { contains: true }));\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\nmicromatch.matchKeys = (obj, patterns, options) => {\n    if (!utils$1.isObject(obj)) {\n        throw new TypeError('Expected the first argument to be an object');\n    }\n    let keys = micromatch(Object.keys(obj), patterns, options);\n    let res = {};\n    for (let key of keys)\n        res[key] = obj[key];\n    return res;\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.some = (list, patterns, options) => {\n    let items = [].concat(list);\n    for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch$1(String(pattern), options);\n        if (items.some(item => isMatch(item))) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.every = (list, patterns, options) => {\n    let items = [].concat(list);\n    for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch$1(String(pattern), options);\n        if (!items.every(item => isMatch(item))) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.all = (str, patterns, options) => {\n    if (typeof str !== 'string') {\n        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n    }\n    return [].concat(patterns).every(p => picomatch$1(p, options)(str));\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\nmicromatch.capture = (glob, input, options) => {\n    let posix = utils$1.isWindows(options);\n    let regex = picomatch$1.makeRe(String(glob), Object.assign({}, options, { capture: true }));\n    let match = regex.exec(posix ? utils$1.toPosixSlashes(input) : input);\n    if (match) {\n        return match.slice(1).map(v => v === void 0 ? '' : v);\n    }\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\nmicromatch.makeRe = (...args) => picomatch$1.makeRe(...args);\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\nmicromatch.scan = (...args) => picomatch$1.scan(...args);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\nmicromatch.parse = (patterns, options) => {\n    let res = [];\n    for (let pattern of [].concat(patterns || [])) {\n        for (let str of braces_1(String(pattern), options)) {\n            res.push(picomatch$1.parse(str, options));\n        }\n    }\n    return res;\n};\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\nmicromatch.braces = (pattern, options) => {\n    if (typeof pattern !== 'string')\n        throw new TypeError('Expected a string');\n    if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n        return [pattern];\n    }\n    return braces_1(pattern, options);\n};\n/**\n * Expand braces\n */\nmicromatch.braceExpand = (pattern, options) => {\n    if (typeof pattern !== 'string')\n        throw new TypeError('Expected a string');\n    return micromatch.braces(pattern, Object.assign({}, options, { expand: true }));\n};\n/**\n * Expose micromatch\n */\nvar micromatch_1 = micromatch;\n\nfunction ensureArray(thing) {\n    if (Array.isArray(thing))\n        return thing;\n    if (thing == undefined)\n        return [];\n    return [thing];\n}\n\nfunction getMatcherString(id, resolutionBase) {\n    if (resolutionBase === false) {\n        return id;\n    }\n    return resolve(...(typeof resolutionBase === 'string' ? [resolutionBase, id] : [id]));\n}\nconst createFilter = function createFilter(include, exclude, options) {\n    const resolutionBase = options && options.resolve;\n    const getMatcher = (id) => {\n        return id instanceof RegExp\n            ? id\n            : {\n                test: micromatch_1.matcher(getMatcherString(id, resolutionBase)\n                    .split(sep)\n                    .join('/'), { dot: true })\n            };\n    };\n    const includeMatchers = ensureArray(include).map(getMatcher);\n    const excludeMatchers = ensureArray(exclude).map(getMatcher);\n    return function (id) {\n        if (typeof id !== 'string')\n            return false;\n        if (/\\0/.test(id))\n            return false;\n        id = id.split(sep).join('/');\n        for (let i = 0; i < excludeMatchers.length; ++i) {\n            const matcher = excludeMatchers[i];\n            if (matcher.test(id))\n                return false;\n        }\n        for (let i = 0; i < includeMatchers.length; ++i) {\n            const matcher = includeMatchers[i];\n            if (matcher.test(id))\n                return true;\n        }\n        return !includeMatchers.length;\n    };\n};\n\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';\nconst builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';\nconst forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));\nforbiddenIdentifiers.add('');\nconst makeLegalIdentifier = function makeLegalIdentifier(str) {\n    str = str.replace(/-(\\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, '_');\n    if (/\\d/.test(str[0]) || forbiddenIdentifiers.has(str)) {\n        str = `_${str}`;\n    }\n    return str || '_';\n};\n\nfunction stringify$2(obj) {\n    return (JSON.stringify(obj) || 'undefined').replace(/[\\u2028\\u2029]/g, char => `\\\\u${('000' + char.charCodeAt(0).toString(16)).slice(-4)}`);\n}\nfunction serializeArray(arr, indent, baseIndent) {\n    let output = '[';\n    const separator = indent ? '\\n' + baseIndent + indent : '';\n    for (let i = 0; i < arr.length; i++) {\n        const key = arr[i];\n        output += `${i > 0 ? ',' : ''}${separator}${serialize(key, indent, baseIndent + indent)}`;\n    }\n    return output + `${indent ? '\\n' + baseIndent : ''}]`;\n}\nfunction serializeObject(obj, indent, baseIndent) {\n    let output = '{';\n    const separator = indent ? '\\n' + baseIndent + indent : '';\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const stringKey = makeLegalIdentifier(key) === key ? key : stringify$2(key);\n        output += `${i > 0 ? ',' : ''}${separator}${stringKey}:${indent ? ' ' : ''}${serialize(obj[key], indent, baseIndent + indent)}`;\n    }\n    return output + `${indent ? '\\n' + baseIndent : ''}}`;\n}\nfunction serialize(obj, indent, baseIndent) {\n    if (obj === Infinity)\n        return 'Infinity';\n    if (obj === -Infinity)\n        return '-Infinity';\n    if (obj === 0 && 1 / obj === -Infinity)\n        return '-0';\n    if (obj instanceof Date)\n        return 'new Date(' + obj.getTime() + ')';\n    if (obj instanceof RegExp)\n        return obj.toString();\n    if (obj !== obj)\n        return 'NaN';\n    if (Array.isArray(obj))\n        return serializeArray(obj, indent, baseIndent);\n    if (obj === null)\n        return 'null';\n    if (typeof obj === 'object')\n        return serializeObject(obj, indent, baseIndent);\n    return stringify$2(obj);\n}\nconst dataToEsm = function dataToEsm(data, options = {}) {\n    const t = options.compact ? '' : 'indent' in options ? options.indent : '\\t';\n    const _ = options.compact ? '' : ' ';\n    const n = options.compact ? '' : '\\n';\n    const declarationType = options.preferConst ? 'const' : 'var';\n    if (options.namedExports === false ||\n        typeof data !== 'object' ||\n        Array.isArray(data) ||\n        data instanceof Date ||\n        data instanceof RegExp ||\n        data === null) {\n        const code = serialize(data, options.compact ? null : t, '');\n        const __ = _ || (/^[{[\\-\\/]/.test(code) ? '' : ' ');\n        return `export default${__}${code};`;\n    }\n    let namedExportCode = '';\n    const defaultExportRows = [];\n    const dataKeys = Object.keys(data);\n    for (let i = 0; i < dataKeys.length; i++) {\n        const key = dataKeys[i];\n        if (key === makeLegalIdentifier(key)) {\n            if (options.objectShorthand)\n                defaultExportRows.push(key);\n            else\n                defaultExportRows.push(`${key}:${_}${key}`);\n            namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(data[key], options.compact ? null : t, '')};${n}`;\n        }\n        else {\n            defaultExportRows.push(`${stringify$2(key)}:${_}${serialize(data[key], options.compact ? null : t, '')}`);\n        }\n    }\n    return (namedExportCode + `export default${_}{${n}${t}${defaultExportRows.join(`,${n}${t}`)}${n}};${n}`);\n};\n\nexport { addExtension, attachScopes, createFilter, dataToEsm, extractAssignedNames, makeLegalIdentifier };\n"],"names":[],"mappings":"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"}